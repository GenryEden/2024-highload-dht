# Отчет по модулю 1

## Наполнение
Для наполнения был использован следующий скрипт на lua

```lua

counter = 6000000

body = function() 
    ans = ''
    for i = 1, 100, 1
    do
        ans = ans .. math.random(1, 100) 
    end
    return ans
end

request = function() 
    path = "/v0/entity?id=" .. counter 
    counter = counter + 1
    wrk.body = body() 
    return wrk.format("PUT", path)
end
```

Таким образом было записано ~27'000'000 ключей,
а общий занимаемый объем составил примерно 5.8 GiB по 327 SSTable

## Профилирование на чтение

Проведем профилирование системы при 1'500 RPS (точка разладки ~2000 RPS)
в течение 240 сек при работе на чтение

Нагрузка производится при помощи следующего скрипта

```lua
request = function()
path = "/v0/entity?id=" .. math.random(0, 50000000)
return wrk.format("GET", path)
end
```

Диапазон выбран так, чтобы обеспечивать примерно равномерное соотношение
существующими и несуществующими ключами.

[ЦПУ на чтение](cpu_read.html)

Нетрудно заметить, что подавляющее 
большинство времени уходит на поиск ключа
по всем SSTable, что решается применением bloom фильтра, а так
же агрессивным автоматическим compact'ом

[Аллокации на чтение](alloc_read.html)

Все аллокации выполняются исключительно для возврата/получения значения
для представления пользователю/интерфейсу DAO, промежуточных избыточных аллокаций не наблюдается

[Блокировки на чтение](lock_read.html)

Блокировок нет

## Профилирование на запись

Профилирование на запись проводилось при 12'000 RPS (точка разладки примерно 
15'000 RPS) в течение 240 сек

Нагрузка производилась при помощи следующего скрипта

```lua
body = function() 
    ans = ''
    for i = 1, 100, 1
    do
        ans = ans .. math.random(1, 100) 
    end
    return ans
end

request = function() 
    path = "/v0/entity?id=" .. math.random(0, 50000000) 
    wrk.body = body() 
    return wrk.format("PUT", path)
end
```

[ЦПУ на запись](cpu_write.html)

Основное время уходит на операции сетевого ввода-вывода.
Его можно сократить, используя другие протоколы, которые будут 
обеспечивать меньшие служебные нагрузки

[Аллокации на запись](alloc_write.html)

Нагрузки по аллокациям аналогичны тем, что проявляются при загрузках на чтение

[Блокировки на запись](lock_write.html)

При записи срабатывают лишь блокировка
при изменении набора таблиц (flush / compact)